{"version":3,"sources":["../../src/main/decorators.ts"],"names":[],"mappings":"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","file":"decorators.js","sourcesContent":["import { metadata } from 'aurelia-metadata';\nimport { Container, All, Parent, Lazy, Optional, Factory, NewInstance } from 'aurelia-dependency-injection';\nimport { DynamicNewInstance } from './resolvers';\n\nvar metadataType = 'design:type';\nvar emptyParameters = Object.freeze([]);\n\n/**\n * Decorator: Directs the TypeScript transpiler to write-out type metadata for the decorated class/property.\n */\nexport function autoinject(potentialTarget?: any, potentialKey?: any): any {\n    const deco = function (target, key, descriptor?) {\n        if (!key) {\n            target.inject = metadata.getOwn(metadata.paramTypes, target, key) || emptyParameters;\n        } else if (!descriptor) {\n            if (!target.constructor.injectProperties) {\n                target.constructor.injectProperties = Object.create(null);\n            }\n            target.constructor.injectProperties[key] = metadata.getOwn(metadataType, target, key);\n        }\n    };\n    return potentialTarget ? deco(potentialTarget, potentialKey) : deco;\n}\n\nfunction injectFn(target, key, descriptor, ...inject: any[]) {\n    if (key) {\n        if (descriptor && descriptor.configurable) {\n            descriptor.value.inject = inject;\n        } else {\n            let injectProperties = target.constructor.injectProperties;\n            if (!injectProperties) {\n                target.constructor.injectProperties = injectProperties = Object.create(null);\n            }\n            injectProperties[key] = inject[0];\n            if (descriptor) {\n                descriptor.writable = true;\n            }\n        }\n    } else {\n        target.inject = inject;\n    }\n};\n\n/**\n * Decorator: Specifies the dependencies that should be injected by the DI Container into the decorated class/function/property.\n */\nexport function inject(...rest: any[]): Function {\n    return function (target, key, descriptor) {\n        injectFn(target, key, descriptor, ...rest);\n    };\n}\n\n/**\n * Decorator: Used to allow functions/classes to specify resolution of all matches to a key.\n */\nexport function all(type) {\n    return function (target, key, desc?) {\n        injectFn(target, key, desc, All.of(type));\n    };\n}\n\n/**\n * Decorator: Used to inject the dependency from the parent container instead of the current one.\n */\nexport function parent(type) {\n    return function(target, key, desc?) {\n        if (!type) {\n            // typescript\n            type = metadata.get(metadataType, target, key);\n        }\n        injectFn(target, key, desc, Parent.of(type));\n    };\n}\n\n/**\n * Decorator: Used to allow functions/classes to specify lazy resolution logic.\n */\nexport function lazy(type) {\n    return function(target, key, desc?) {\n        injectFn(target, key, desc, Lazy.of(type));\n    };\n}\n\n/**\n * Decorator: Used to allow functions/classes to specify an optional dependency, which will be resolved only if already registred with the container.\n */\nexport function optional(type) {\n    return function(target, key, desc?) {\n        if (!type) {\n            // typescript\n            type = metadata.get(metadataType, target, key);\n        }\n        injectFn(target, key, desc, Optional.of(type));\n    };\n}\n\n/**\n * Decorator: Used to allow injecting dependencies but also passing data to the constructor.\n */\nexport function factory(type) {\n    return function(target, key, desc?) {\n        injectFn(target, key, desc, Factory.of(type));\n    };\n}\n\n/**\n * Decorator: Used to inject a new instance of a dependency, without regard for existing\n * instances in the container.\n */\nexport function newInstance(type, ...dynamicDependencies: any[]) {\n    return function (target, key, desc?) {\n        injectFn(target, key, desc, DynamicNewInstance.of(type, ...dynamicDependencies));\n    };\n}\n"]}